# -*- coding:utf-8 -*-

# Some utils funciton for strings.

import re
import nltk

dataset_utils_string_english_vocab = set([w.lower() for w in nltk.corpus.words.words()])

def multi_spaces_to_one(s):
  s = re.sub(r'\s\s+', ' ', s)
  return s

def regular_process(s, minimum_length=1,
                    remove_strings=None,
                    replace_maps=None):
  """Some regular processes for a string.
  
  Parameters
  ----------
  s : str
    The input.
  minimum_length : int
    Minimum length of the input, if input has less characters,
    return empty string.
  remove_strings : list of str

  replace_maps : dict

  """
  if remove_strings is not None:
    if not isinstance(remove_strings, list):
      remove_strings = [remove_strings]
    for p in remove_strings:
      s = re.sub(p, '', s)
  if replace_maps is not None:
    for k, v in replace_maps.items():
      s = re.sub(k, v, s)
  if len(s) < minimum_length:
    s = ''
  return s

def encode_decode_rm_specified_code(text):
  """
  1. Encode to get bytes
  2. Check ascii
  3. rm some
  4. decode
  """
  byte_rep = text.encode()
  byte_rmed_list = []
  for i, b in enumerate(byte_rep):
    if i < len(byte_rep) - 2 and b == 239 and byte_rep[i + 1] == 172 \
        and byte_rep[i + 2] == 129:
      byte_rmed_list.append(105)
      byte_rmed_list.append(102)
      continue
    if i > 0 and b == 172 and i < len(byte_rep) - 1 and byte_rep[i - 1] == 239 \
        and byte_rep[i + 1] == 129:
      continue
    if b == 129 and i > 1 and byte_rep[i - 1] == 172 and byte_rep[i - 2] == 172:
        continue
    if b >=0 and b <= 126:
      byte_rmed_list.append(b)
      continue
    byte_rmed_list.append(32)
  byte_rep = bytes(byte_rmed_list)
  text = byte_rep.decode('utf-8')
  return text

def connect_some_f_pattern(text, infix='fi'):
  """HTML generated by `pdf2html` will fail at some *ff*, *fi* words.
  
  e.g.
  ' ef icient ' -> ' efficient ' if infix='fi'
  ' nd ' -> ' find ' if infix='fi'
  """
  # TODO(zcq) May be very slow
  spe_wrods = [w for w in dataset_utils_string_english_vocab if infix in w]
  for w in spe_wrods:
    idx = w.find(infix)
    pre = w[:idx]
    suf = w[idx + len(infix):]
    text = re.sub(r'\s+%s\s{1,3}%s\s+' % (pre, suf), ' %sfi%s ' % (pre, suf), text)
  return text

def get_center_and_context(word_list, windows=0, filter_func=None):
  """Get center word and its context from a word list.

  Parameters
  ----------
  word_list : list of str
    Input word list.
  windows : int
    The window length, if 0, means window = lenght of word_list
  filter_func : callable object
    If not None, for every word in word_list, abandon the word when
    this function return fasle.

  Returns
  -------
  list of (center_word, context_words_list)
  """
  if window and window % 2 != 1:
    raise ValueError("window should be odd to make sure there is one "
                      "center word, but got %d" % window)



